# H3 Geospatial Development Rules

## 🌐 H3 Geospatial Indexing Framework

### Core Principles
- **H3 is a hierarchical geospatial indexing system** that partitions the world into hexagonal cells
- **Resolution-based hierarchy**: 15 resolutions (0-14) with increasing precision
- **Icosahedron projection**: Uses a modified icosahedron for global coverage
- **Hexagonal grid**: Provides uniform cell sizes and efficient neighbor relationships
- **Hierarchical operations**: Parent-child relationships enable multi-resolution analysis

## 📚 H3 Python Library API Reference

### Core Functions (h3 library v4.3.0+)
```python
import h3

# Coordinate conversion
h3.latlng_to_cell(lat, lng, res)           # Convert lat/lng to H3 cell
h3.cell_to_latlng(cell)                    # Convert H3 cell to lat/lng center
h3.cell_to_boundary(cell)                  # Get cell boundary coordinates

# Grid operations
h3.grid_disk(cell, k)                      # Get cells within k steps
h3.grid_ring(cell, k)                      # Get cells at exactly k steps
h3.grid_path_cells(cell1, cell2)          # Find path between cells
h3.grid_distance(cell1, cell2)            # Calculate grid distance

# Hierarchy operations
h3.cell_to_parent(cell, res)               # Get parent cell at resolution
h3.cell_to_children(cell, res)             # Get child cells at resolution
h3.get_resolution(cell)                    # Get cell resolution

# Geometric properties
h3.cell_area(cell, unit='km2')            # Calculate cell area
h3.average_hexagon_edge_length(res, unit='km')  # Get edge length by resolution
h3.edge_length(edge, unit='km')           # Get edge length

# Validation and analysis
h3.is_valid_cell(cell)                     # Validate H3 cell
h3.is_pentagon(cell)                       # Check if cell is pentagon
h3.is_res_class_III(res)                   # Check if resolution is class III
h3.get_base_cell_number(cell)              # Get base cell number
h3.get_icosahedron_faces(cell)             # Get icosahedron faces

# Compact operations
h3.compact_cells(cells)                    # Compact cell set
h3.uncompact_cells(cells, res)             # Uncompact to resolution

# Local coordinate system
h3.cell_to_local_ij(cell, origin)         # Convert to local coordinates
h3.local_ij_to_cell(origin, i, j)         # Convert from local coordinates

# Distance calculations
h3.great_circle_distance(lat1, lng1, lat2, lng2)  # Great circle distance
h3.haversine_distance(lat1, lng1, lat2, lng2)     # Haversine distance

# Utility functions
h3.num_cells(res)                          # Number of cells at resolution
h3.get_icosahedron_faces(cell)             # Get icosahedron faces
```

## 🎯 Development Standards

### 1. API Consistency
- **Always use the installed h3 library**: `import h3` not local modules
- **Function naming**: Use exact h3 library function names
- **Parameter order**: Follow h3 library parameter order exactly
- **Return types**: Handle actual return types (tuple for boundaries, etc.)
- **Error handling**: Catch specific h3 exceptions (ValueError, H3FailedError)

### 2. Resolution Guidelines
- **Resolution range**: 0-14 (0 = coarsest, 14 = finest)
- **Typical use cases**:
  - 0-3: Global/continental analysis
  - 4-7: Regional/city analysis  
  - 8-10: Neighborhood/street analysis
  - 11-14: Building/precise analysis
- **Performance considerations**: Higher resolutions = more cells = slower operations

### 3. Coordinate System
- **Latitude**: -90 to 90 degrees
- **Longitude**: -180 to 180 degrees
- **WGS84**: Standard coordinate reference system
- **Boundary format**: List of (lat, lng) tuples
- **Center point**: Single (lat, lng) tuple

### 4. Cell Properties
- **Hexagonal cells**: 6 vertices, 6 edges (most resolutions)
- **Pentagonal cells**: 5 vertices, 5 edges (resolution 0 only)
- **Area variation**: Larger at poles, smaller at equator
- **Edge length**: Varies by resolution and latitude

## 🧪 Testing Standards

### 1. Unit Test Requirements
```python
import unittest
import h3

class TestH3Operations(unittest.TestCase):
    def setUp(self):
        # Use realistic test data
        self.test_cell = "8928308280fffff"  # Resolution 9 cell
        self.test_lat, self.test_lng = 37.7749, -122.4194  # San Francisco
        
    def test_coordinate_conversion(self):
        # Test lat/lng to cell conversion
        cell = h3.latlng_to_cell(self.test_lat, self.test_lng, 9)
        self.assertIsInstance(cell, str)
        self.assertEqual(h3.get_resolution(cell), 9)
        
    def test_boundary_operations(self):
        # Test boundary extraction
        boundary = h3.cell_to_boundary(self.test_cell)
        self.assertIsInstance(boundary, tuple)
        self.assertGreaterEqual(len(boundary), 5)  # Account for pentagons
```

### 2. Test Data Guidelines
- **Use realistic coordinates**: Major cities, landmarks
- **Test multiple resolutions**: 0, 5, 9, 12 for coverage
- **Include edge cases**: Poles, equator, international date line
- **Test error conditions**: Invalid cells, out-of-bounds coordinates
- **Performance benchmarks**: Large grids, complex operations

### 3. Assertion Patterns
```python
# Cell validation
self.assertTrue(h3.is_valid_cell(cell))
self.assertEqual(h3.get_resolution(cell), expected_res)

# Boundary validation  
self.assertIsInstance(boundary, tuple)
self.assertGreaterEqual(len(boundary), 5)  # Hexagons and pentagons

# Grid operations
self.assertIn(target_cell, grid_cells)
self.assertEqual(len(grid_cells), expected_count)

# Error handling
with self.assertRaises(ValueError):
    h3.latlng_to_cell(100, 200, 9)  # Invalid coordinates
```

## 🔧 Implementation Guidelines

### 1. Function Design
```python
def analyze_spatial_distribution(cells, resolution):
    """
    Analyze spatial distribution of H3 cells.
    
    Args:
        cells (list): List of H3 cell strings
        resolution (int): Target resolution for analysis
        
    Returns:
        dict: Spatial statistics including area, density, distribution
    """
    if not cells:
        return {"error": "No cells provided"}
        
    # Calculate total area
    total_area = sum(h3.cell_area(cell, unit='km2') for cell in cells)
    
    # Calculate density metrics
    cell_count = len(cells)
    avg_area = total_area / cell_count if cell_count > 0 else 0
    
    return {
        "total_area_km2": total_area,
        "cell_count": cell_count,
        "average_cell_area_km2": avg_area,
        "resolution": resolution
    }
```

### 2. Error Handling
```python
def safe_h3_operation(func, *args, **kwargs):
    """Safely execute H3 operations with proper error handling."""
    try:
        return {"result": func(*args, **kwargs), "error": None}
    except ValueError as e:
        return {"result": None, "error": f"Invalid input: {e}"}
    except Exception as e:
        return {"result": None, "error": f"Unexpected error: {e}"}
```

### 3. Performance Optimization
```python
# Use sets for fast lookups
cell_set = set(cells)

# Batch operations for large datasets
def process_large_grid(base_cell, radius, resolution):
    """Process large H3 grids efficiently."""
    grid_cells = h3.grid_disk(base_cell, radius)
    
    # Process in batches
    batch_size = 1000
    results = []
    
    for i in range(0, len(grid_cells), batch_size):
        batch = grid_cells[i:i + batch_size]
        batch_results = [h3.cell_area(cell) for cell in batch]
        results.extend(batch_results)
    
    return results
```

## 🌐 Web Resources and References

### Official Documentation
- **H3 Documentation**: https://h3geo.org/docs
- **Python H3 Library**: https://github.com/uber/h3-py
- **H3 Resolution Table**: https://h3geo.org/docs/core-library/resolution-table
- **H3 API Reference**: https://h3geo.org/docs/api/indexing

### Best Practices
- **Uber Engineering Blog**: H3 grid system design principles
- **Geospatial Analysis**: Real-world H3 use cases and patterns
- **Performance Optimization**: Large-scale H3 processing techniques
- **Visualization**: H3 data visualization best practices

### Community Resources
- **H3 GitHub Discussions**: https://github.com/uber/h3/discussions
- **Stack Overflow**: H3 geospatial indexing questions
- **Geospatial Forums**: H3 implementation discussions
- **Academic Papers**: H3 mathematical foundations

## 📊 Data Patterns

### 1. Common H3 Operations
```python
# Multi-resolution analysis
def hierarchical_analysis(cells):
    """Analyze cells across multiple resolutions."""
    results = {}
    for res in range(0, 15):
        parent_cells = set()
        for cell in cells:
            if h3.get_resolution(cell) >= res:
                parent = h3.cell_to_parent(cell, res)
                parent_cells.add(parent)
        results[res] = len(parent_cells)
    return results

# Spatial clustering
def spatial_clustering(cells, distance_threshold):
    """Cluster H3 cells based on spatial proximity."""
    clusters = []
    processed = set()
    
    for cell in cells:
        if cell in processed:
            continue
            
        # Find connected cells
        cluster = set()
        to_process = [cell]
        
        while to_process:
            current = to_process.pop()
            if current in processed:
                continue
                
            cluster.add(current)
            processed.add(current)
            
            # Add neighbors within threshold
            neighbors = h3.grid_disk(current, distance_threshold)
            for neighbor in neighbors:
                if neighbor in cells and neighbor not in processed:
                    to_process.append(neighbor)
        
        clusters.append(list(cluster))
    
    return clusters
```

### 2. Performance Patterns
```python
# Efficient grid operations
def optimized_grid_analysis(base_cell, max_radius):
    """Optimized grid analysis with early termination."""
    results = []
    visited = set()
    
    for radius in range(max_radius + 1):
        ring_cells = h3.grid_ring(base_cell, radius)
        
        # Process only new cells
        new_cells = [cell for cell in ring_cells if cell not in visited]
        if not new_cells:
            break
            
        # Analyze new cells
        for cell in new_cells:
            area = h3.cell_area(cell)
            results.append({"cell": cell, "radius": radius, "area": area})
            visited.add(cell)
    
    return results
```

## 🚀 Advanced Features

### 1. Custom H3 Utilities
```python
def h3_statistics(cells):
    """Calculate comprehensive H3 statistics."""
    if not cells:
        return {}
    
    # Basic statistics
    total_area = sum(h3.cell_area(cell) for cell in cells)
    resolutions = [h3.get_resolution(cell) for cell in cells]
    
    # Resolution distribution
    res_dist = {}
    for res in resolutions:
        res_dist[res] = res_dist.get(res, 0) + 1
    
    # Spatial distribution
    pentagons = sum(1 for cell in cells if h3.is_pentagon(cell))
    class_iii = sum(1 for res in resolutions if h3.is_res_class_III(res))
    
    return {
        "total_cells": len(cells),
        "total_area_km2": total_area,
        "average_area_km2": total_area / len(cells),
        "resolution_distribution": res_dist,
        "pentagon_count": pentagons,
        "class_iii_count": class_iii,
        "min_resolution": min(resolutions),
        "max_resolution": max(resolutions)
    }
```

### 2. Visualization Support
```python
def prepare_h3_visualization(cells, properties=None):
    """Prepare H3 cells for visualization."""
    features = []
    
    for cell in cells:
        boundary = h3.cell_to_boundary(cell)
        
        # Convert to GeoJSON format
        feature = {
            "type": "Feature",
            "geometry": {
                "type": "Polygon",
                "coordinates": [boundary]
            },
            "properties": {
                "cell": cell,
                "resolution": h3.get_resolution(cell),
                "area_km2": h3.cell_area(cell, unit='km2')
            }
        }
        
        # Add custom properties
        if properties and cell in properties:
            feature["properties"].update(properties[cell])
        
        features.append(feature)
    
    return {
        "type": "FeatureCollection",
        "features": features
    }
```

## 🔍 Quality Assurance

### 1. Code Review Checklist
- [ ] Uses correct h3 library functions
- [ ] Handles all return types properly
- [ ] Includes comprehensive error handling
- [ ] Tests edge cases and error conditions
- [ ] Optimizes for performance with large datasets
- [ ] Documents mathematical foundations
- [ ] Includes realistic test data
- [ ] Validates coordinate inputs
- [ ] Handles resolution constraints
- [ ] Tests multi-resolution operations

### 2. Performance Benchmarks
```python
def benchmark_h3_operations():
    """Benchmark common H3 operations."""
    import time
    
    # Test data
    base_cell = "8928308280fffff"
    test_coords = [(37.7749, -122.4194), (40.7128, -74.0060)]
    
    operations = [
        ("latlng_to_cell", lambda: h3.latlng_to_cell(37.7749, -122.4194, 9)),
        ("cell_to_boundary", lambda: h3.cell_to_boundary(base_cell)),
        ("grid_disk", lambda: h3.grid_disk(base_cell, 5)),
        ("cell_area", lambda: h3.cell_area(base_cell)),
    ]
    
    results = {}
    for name, operation in operations:
        start_time = time.perf_counter()
        for _ in range(1000):
            operation()
        end_time = time.perf_counter()
        results[name] = (end_time - start_time) / 1000
    
    return results
```

## 📝 Documentation Standards

### 1. Function Documentation
```python
def h3_spatial_analysis(cells, analysis_type="basic"):
    """
    Perform spatial analysis on H3 cells.
    
    This function provides comprehensive spatial analysis capabilities for H3
    geospatial data, including area calculations, density analysis, and
    distribution statistics.
    
    Args:
        cells (list): List of H3 cell strings to analyze
        analysis_type (str): Type of analysis to perform
            - "basic": Area and count statistics
            - "density": Spatial density analysis
            - "distribution": Resolution and spatial distribution
            - "comprehensive": All analyses combined
    
    Returns:
        dict: Analysis results with the following structure:
            - total_area_km2 (float): Total area of all cells
            - cell_count (int): Number of cells analyzed
            - average_area_km2 (float): Average cell area
            - resolution_distribution (dict): Cells per resolution
            - spatial_density (dict): Density metrics (if applicable)
    
    Raises:
        ValueError: If cells list is empty or contains invalid cells
        TypeError: If cells is not a list or analysis_type is not a string
    
    Example:
        >>> cells = ["8928308280fffff", "8928308281fffff"]
        >>> results = h3_spatial_analysis(cells, "comprehensive")
        >>> print(results["total_area_km2"])
        0.0004
    """
```

### 2. Mathematical Documentation
```python
def calculate_h3_spatial_metrics(cells):
    """
    Calculate spatial metrics for H3 cell collections.
    
    Mathematical Foundation:
    - Area calculation uses spherical trigonometry
    - Density = cell_count / total_area
    - Spatial distribution uses Voronoi tessellation principles
    - Resolution analysis follows H3 hierarchical structure
    
    References:
    - H3: A hierarchical hexagonal geospatial indexing system
    - Uber Engineering: H3 grid system design
    - Geospatial Analysis: Principles and Applications
    """
```

## 🎯 Success Criteria

### 1. Functional Requirements
- [ ] All H3 operations use correct library functions
- [ ] Comprehensive test coverage (100% of functions)
- [ ] Proper error handling for all edge cases
- [ ] Performance optimization for large datasets
- [ ] Multi-resolution analysis capabilities
- [ ] Spatial clustering and analysis features
- [ ] Visualization and export capabilities

### 2. Quality Requirements
- [ ] No mock or placeholder implementations
- [ ] Real mathematical calculations and analysis
- [ ] Comprehensive documentation and examples
- [ ] Performance benchmarks and optimization
- [ ] Cross-platform compatibility
- [ ] Memory-efficient operations
- [ ] Scalable architecture

### 3. Integration Requirements
- [ ] Compatible with GEO-INFER framework
- [ ] Follows established module patterns
- [ ] Supports cross-module data flow
- [ ] Implements proper API interfaces
- [ ] Maintains system coherence
- [ ] Extensible for future enhancements

---

**Remember**: H3 is a sophisticated geospatial indexing system. Every implementation should demonstrate deep understanding of hexagonal geometry, hierarchical relationships, and spatial analysis principles. Focus on real-world applications, mathematical rigor, and performance optimization while maintaining code clarity and comprehensive documentation. 