"""
VulnerabilityModel: Base class for modeling asset vulnerability to hazards.

This module provides the VulnerabilityModel class which serves as the foundation for
modeling how different assets (buildings, infrastructure, population) respond to
hazard intensities to generate damage ratios.
"""

from typing import Dict, List, Any, Optional
import numpy as np
import os
import json


class VulnerabilityModel:
    """
    Base class for modeling asset vulnerability to hazards.
    
    The VulnerabilityModel handles:
    - Mapping hazard intensity to damage ratios
    - Accounting for asset characteristics
    - Managing uncertainty in vulnerability relationships
    """
    
    def __init__(self, vulnerability_type: str, params: Dict[str, Any]):
        """
        Initialize the vulnerability model with the specified parameters.
        
        Args:
            vulnerability_type (str): Type of vulnerability model (e.g., 'building', 'infrastructure')
            params (Dict[str, Any]): Parameters for the vulnerability model configuration
        """
        self.vulnerability_type = vulnerability_type
        self.params = params
        
        # Get specific parameters with defaults
        self.classification_scheme = params.get("classification_scheme", "custom")
        self.include_factors = params.get("include_factors", [])
        self.uncertainty_method = params.get("uncertainty_method", "none")
        
        # Load vulnerability curves and data
        self._load_vulnerability_data()
    
    def _load_vulnerability_data(self):
        """
        Load vulnerability curves and data.
        
        This method should be overridden by subclasses to load specific vulnerability
        data for the particular asset types.
        """
        # This is a placeholder implementation
        # In a real implementation, this would load data from files or databases
        
        # Create a simple dictionary of vulnerability curves for different hazard types
        # In a real model, these would be loaded from external files or a database
        
        # Structure: {hazard_type: {asset_type: {intensity_values: [], damage_ratios: []}}}
        self.vulnerability_curves = {
            "flood": self._generate_flood_vulnerability_curves(),
            "earthquake": self._generate_earthquake_vulnerability_curves(),
            "hurricane": self._generate_hurricane_vulnerability_curves(),
            "wildfire": self._generate_wildfire_vulnerability_curves()
        }
    
    def _generate_flood_vulnerability_curves(self) -> Dict[str, Dict[str, List[float]]]:
        """
        Generate simplified flood vulnerability curves for different asset types.
        
        Returns:
            Dict: Dictionary of flood vulnerability curves by asset type
        """
        # Simple flood vulnerability curves based on depth-damage relationships
        curves = {}
        
        # Residential buildings
        curves["residential"] = {
            "intensity_values": [0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0],  # water depth in meters
            "damage_ratios": [0.0, 0.15, 0.25, 0.40, 0.55, 0.75, 0.85]  # damage ratio
        }
        
        # Commercial buildings
        curves["commercial"] = {
            "intensity_values": [0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0],
            "damage_ratios": [0.0, 0.10, 0.20, 0.35, 0.50, 0.70, 0.80]
        }
        
        # Roads
        curves["road"] = {
            "intensity_values": [0.0, 0.5, 1.0, 1.5, 2.0, 3.0, 4.0],
            "damage_ratios": [0.0, 0.05, 0.10, 0.20, 0.30, 0.50, 0.70]
        }
        
        # Bridges
        curves["bridge"] = {
            "intensity_values": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0],
            "damage_ratios": [0.0, 0.05, 0.15, 0.30, 0.50, 0.70, 0.90]
        }
        
        return curves
    
    def _generate_earthquake_vulnerability_curves(self) -> Dict[str, Dict[str, List[float]]]:
        """
        Generate simplified earthquake vulnerability curves for different asset types.
        
        Returns:
            Dict: Dictionary of earthquake vulnerability curves by asset type
        """
        # Simple earthquake vulnerability curves based on PGA-damage relationships
        curves = {}
        
        # Masonry buildings
        curves["masonry"] = {
            "intensity_values": [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6],  # PGA in g
            "damage_ratios": [0.0, 0.10, 0.25, 0.45, 0.65, 0.80, 0.90]
        }
        
        # Concrete buildings
        curves["concrete"] = {
            "intensity_values": [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6],
            "damage_ratios": [0.0, 0.05, 0.15, 0.30, 0.50, 0.70, 0.85]
        }
        
        # Steel buildings
        curves["steel"] = {
            "intensity_values": [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6],
            "damage_ratios": [0.0, 0.03, 0.10, 0.20, 0.40, 0.60, 0.75]
        }
        
        # Wood buildings
        curves["wood"] = {
            "intensity_values": [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6],
            "damage_ratios": [0.0, 0.05, 0.15, 0.25, 0.40, 0.60, 0.80]
        }
        
        return curves
    
    def _generate_hurricane_vulnerability_curves(self) -> Dict[str, Dict[str, List[float]]]:
        """
        Generate simplified hurricane vulnerability curves for different asset types.
        
        Returns:
            Dict: Dictionary of hurricane vulnerability curves by asset type
        """
        # Simple hurricane vulnerability curves based on wind speed-damage relationships
        curves = {}
        
        # Residential buildings
        curves["residential"] = {
            "intensity_values": [0, 20, 40, 60, 80, 100, 120, 140, 160],  # wind speed in m/s
            "damage_ratios": [0.0, 0.0, 0.05, 0.15, 0.30, 0.50, 0.70, 0.85, 0.95]
        }
        
        # Commercial buildings
        curves["commercial"] = {
            "intensity_values": [0, 20, 40, 60, 80, 100, 120, 140, 160],
            "damage_ratios": [0.0, 0.0, 0.03, 0.10, 0.25, 0.45, 0.65, 0.80, 0.90]
        }
        
        # Mobile homes
        curves["mobile_home"] = {
            "intensity_values": [0, 20, 40, 60, 80, 100, 120, 140, 160],
            "damage_ratios": [0.0, 0.0, 0.10, 0.30, 0.60, 0.85, 0.95, 1.0, 1.0]
        }
        
        # Power lines
        curves["power_line"] = {
            "intensity_values": [0, 20, 40, 60, 80, 100, 120, 140, 160],
            "damage_ratios": [0.0, 0.0, 0.05, 0.20, 0.40, 0.60, 0.80, 0.90, 0.95]
        }
        
        return curves
    
    def _generate_wildfire_vulnerability_curves(self) -> Dict[str, Dict[str, List[float]]]:
        """
        Generate simplified wildfire vulnerability curves for different asset types.
        
        Returns:
            Dict: Dictionary of wildfire vulnerability curves by asset type
        """
        # Simple wildfire vulnerability curves based on fire intensity-damage relationships
        curves = {}
        
        # Wooden buildings
        curves["wooden"] = {
            "intensity_values": [0, 10, 20, 30, 40, 50, 60],  # fire intensity in kW/m
            "damage_ratios": [0.0, 0.10, 0.30, 0.60, 0.85, 0.95, 1.0]
        }
        
        # Masonry buildings
        curves["masonry"] = {
            "intensity_values": [0, 10, 20, 30, 40, 50, 60],
            "damage_ratios": [0.0, 0.05, 0.15, 0.30, 0.50, 0.70, 0.85]
        }
        
        # Forest
        curves["forest"] = {
            "intensity_values": [0, 10, 20, 30, 40, 50, 60],
            "damage_ratios": [0.0, 0.20, 0.50, 0.80, 0.95, 1.0, 1.0]
        }
        
        # Agricultural land
        curves["agricultural"] = {
            "intensity_values": [0, 10, 20, 30, 40, 50, 60],
            "damage_ratios": [0.0, 0.15, 0.40, 0.70, 0.90, 1.0, 1.0]
        }
        
        return curves
    
    def calculate_damage(self, hazard_type: str, hazard_intensity: float, 
                         asset_properties: Dict[str, Any]) -> float:
        """
        Calculate the damage ratio for an asset based on hazard intensity and asset properties.
        
        Args:
            hazard_type (str): Type of hazard (e.g., 'flood', 'earthquake')
            hazard_intensity (float): Intensity value of the hazard at the asset location
            asset_properties (Dict[str, Any]): Properties of the asset
            
        Returns:
            float: Damage ratio (0.0 to 1.0)
        """
        # Get asset type from properties, with fallback
        asset_type = asset_properties.get("type", "residential")
        
        # Check if we have vulnerability curves for this hazard and asset type
        if hazard_type not in self.vulnerability_curves:
            return 0.0  # No vulnerability data for this hazard
        
        hazard_curves = self.vulnerability_curves[hazard_type]
        
        if asset_type not in hazard_curves:
            # Try to find a reasonable fallback asset type
            if hazard_type == "flood":
                asset_type = "residential"
            elif hazard_type == "earthquake":
                asset_type = "masonry"
            elif hazard_type == "hurricane":
                asset_type = "residential"
            elif hazard_type == "wildfire":
                asset_type = "wooden"
            else:
                # Use the first available asset type as fallback
                asset_type = list(hazard_curves.keys())[0] if hazard_curves else None
                
            if asset_type is None:
                return 0.0  # No vulnerability data available
        
        # Get vulnerability curve for this asset type
        curve = hazard_curves[asset_type]
        intensity_values = curve["intensity_values"]
        damage_ratios = curve["damage_ratios"]
        
        # Handle intensity values outside the range of the curve
        if hazard_intensity <= intensity_values[0]:
            return damage_ratios[0]  # Below minimum intensity
        
        if hazard_intensity >= intensity_values[-1]:
            return damage_ratios[-1]  # Above maximum intensity
        
        # Interpolate damage ratio based on hazard intensity
        for i in range(len(intensity_values) - 1):
            if intensity_values[i] <= hazard_intensity < intensity_values[i+1]:
                # Linear interpolation
                x0, x1 = intensity_values[i], intensity_values[i+1]
                y0, y1 = damage_ratios[i], damage_ratios[i+1]
                
                # Apply linear interpolation: y = y0 + (y1-y0) * (x-x0) / (x1-x0)
                damage_ratio = y0 + (y1 - y0) * (hazard_intensity - x0) / (x1 - x0)
                
                # Apply modification factors based on asset properties
                damage_ratio = self._apply_modification_factors(damage_ratio, hazard_type, asset_properties)
                
                # Add uncertainty if enabled
                if self.uncertainty_method != "none":
                    damage_ratio = self._apply_uncertainty(damage_ratio)
                
                return damage_ratio
        
        # Should not reach here, but return 0 if we somehow do
        return 0.0
    
    def _apply_modification_factors(self, base_damage_ratio: float, hazard_type: str, 
                                   asset_properties: Dict[str, Any]) -> float:
        """
        Apply modification factors to the base damage ratio based on asset properties.
        
        Args:
            base_damage_ratio (float): Base damage ratio from the vulnerability curve
            hazard_type (str): Type of hazard (e.g., 'flood', 'earthquake')
            asset_properties (Dict[str, Any]): Properties of the asset
            
        Returns:
            float: Modified damage ratio
        """
        modified_ratio = base_damage_ratio
        
        # Apply different modification factors based on hazard type
        if hazard_type == "flood":
            # Example: Apply modification for building age
            if "year_built" in asset_properties:
                year_built = asset_properties["year_built"]
                current_year = 2023  # Should use actual current year
                age = current_year - year_built
                
                # Older buildings may be more vulnerable
                if age > 50:
                    modified_ratio *= 1.2
                elif age > 25:
                    modified_ratio *= 1.1
            
            # Example: Apply modification for elevation
            if "elevation" in asset_properties:
                elevation = asset_properties["elevation"]
                if elevation < 0:  # Below sea level
                    modified_ratio *= 1.3
            
            # Example: Apply modification for foundation type
            if "foundation_type" in asset_properties:
                foundation = asset_properties["foundation_type"]
                if foundation == "slab":
                    modified_ratio *= 1.1
                elif foundation == "elevated":
                    modified_ratio *= 0.8
        
        elif hazard_type == "earthquake":
            # Example: Apply modification for building height
            if "stories" in asset_properties:
                stories = asset_properties["stories"]
                if stories > 5:
                    modified_ratio *= 1.15  # Taller buildings may be more vulnerable
            
            # Example: Apply modification for soil conditions
            if "soil_type" in asset_properties:
                soil_type = asset_properties["soil_type"]
                if soil_type == "soft":
                    modified_ratio *= 1.25  # Soft soil can amplify shaking
                elif soil_type == "rock":
                    modified_ratio *= 0.9  # Rock provides better stability
        
        elif hazard_type == "hurricane":
            # Example: Apply modification for roof type
            if "roof_type" in asset_properties:
                roof_type = asset_properties["roof_type"]
                if roof_type == "flat":
                    modified_ratio *= 1.2  # Flat roofs may be more vulnerable
                elif roof_type == "hip":
                    modified_ratio *= 0.85  # Hip roofs may perform better
            
            # Example: Apply modification for building code
            if "building_code" in asset_properties:
                building_code = asset_properties["building_code"]
                if building_code == "post_2000":
                    modified_ratio *= 0.8  # Newer codes may provide better protection
        
        # Ensure the modified ratio is within [0,1]
        return max(0.0, min(1.0, modified_ratio))
    
    def _apply_uncertainty(self, damage_ratio: float) -> float:
        """
        Apply uncertainty to the damage ratio based on the configured method.
        
        Args:
            damage_ratio (float): Deterministic damage ratio
            
        Returns:
            float: Damage ratio with uncertainty applied
        """
        # Different uncertainty methods
        if self.uncertainty_method == "monte_carlo":
            # Apply random variation using a beta distribution
            # Beta distribution is bounded between 0 and 1, making it suitable for damage ratios
            
            # Parameters for beta distribution based on the deterministic damage ratio
            # These parameters are chosen to keep the mean around the deterministic value
            # while introducing reasonable spread
            
            # Avoid extremes for alpha and beta parameters
            mean = damage_ratio
            variance = 0.02  # Configurable parameter for uncertainty spread
            
            # Calculate alpha and beta parameters for beta distribution
            # These formulas ensure the distribution has the desired mean and variance
            if mean == 0 or mean == 1:
                return mean  # No uncertainty at extremes
            
            # Ensure variance is reasonable given the mean
            max_var = mean * (1 - mean)
            variance = min(variance, max_var * 0.5)  # Limit variance to avoid invalid parameters
            
            # Calculate alpha and beta
            t = mean * (1 - mean) / variance - 1
            alpha = mean * t
            beta = (1 - mean) * t
            
            # Generate random value from beta distribution
            uncertain_ratio = np.random.beta(max(0.1, alpha), max(0.1, beta))
            
            return uncertain_ratio
        
        elif self.uncertainty_method == "simple":
            # Apply simple uniform random variation
            # The range of variation increases as the damage ratio moves away from 0 and 1
            
            # Maximum variation at damage_ratio = 0.5, decreasing towards 0 and 1
            max_variation = 0.2 * damage_ratio * (1 - damage_ratio) * 4  # Max 0.2 at damage_ratio = 0.5
            
            # Apply random variation
            variation = np.random.uniform(-max_variation, max_variation)
            uncertain_ratio = damage_ratio + variation
            
            # Ensure result is within [0,1]
            return max(0.0, min(1.0, uncertain_ratio))
        
        else:
            # No uncertainty, return the deterministic value
            return damage_ratio
    
    def save_curves(self, output_directory: str):
        """
        Save vulnerability curves to JSON files.
        
        Args:
            output_directory (str): Directory to save the curve files
        """
        # Create output directory if it doesn't exist
        os.makedirs(output_directory, exist_ok=True)
        
        # Save curves for each hazard type
        for hazard_type, asset_curves in self.vulnerability_curves.items():
            # Create file path
            file_path = os.path.join(output_directory, f"{hazard_type}_vulnerability_curves.json")
            
            # Write to file
            with open(file_path, 'w') as f:
                json.dump(asset_curves, f, indent=2)
    
    def load_curves_from_file(self, file_path: str, hazard_type: str):
        """
        Load vulnerability curves from a JSON file.
        
        Args:
            file_path (str): Path to the curve file
            hazard_type (str): Type of hazard for these curves
        """
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"Vulnerability curve file not found: {file_path}")
        
        # Read from file
        with open(file_path, 'r') as f:
            asset_curves = json.load(f)
        
        # Update the vulnerability curves for this hazard type
        self.vulnerability_curves[hazard_type] = asset_curves


class BuildingVulnerabilityModel(VulnerabilityModel):
    """
    Specialized vulnerability model for buildings.
    """
    
    def __init__(self, params: Dict[str, Any]):
        """
        Initialize the building vulnerability model with the specified parameters.
        
        Args:
            params (Dict[str, Any]): Parameters for the building vulnerability model
        """
        super().__init__(vulnerability_type="building", params=params)
        
        # Building-specific parameters
        self.classification_scheme = params.get("classification_scheme", "hazus")
    
    def _load_vulnerability_data(self):
        """
        Load building-specific vulnerability curves and data.
        """
        super()._load_vulnerability_data()
        
        # Add additional building-specific curves based on classification scheme
        if self.classification_scheme == "hazus":
            # Add HAZUS-specific building classification curves
            # In a real implementation, these would be loaded from HAZUS data files
            pass
        elif self.classification_scheme == "european":
            # Add European building classification curves
            # In a real implementation, these would be loaded from European standards
            pass


class InfrastructureVulnerabilityModel(VulnerabilityModel):
    """
    Specialized vulnerability model for infrastructure.
    """
    
    def __init__(self, params: Dict[str, Any]):
        """
        Initialize the infrastructure vulnerability model with the specified parameters.
        
        Args:
            params (Dict[str, Any]): Parameters for the infrastructure vulnerability model
        """
        super().__init__(vulnerability_type="infrastructure", params=params)
        
        # Infrastructure-specific parameters
        self.infrastructure_types = params.get("types", ["roads", "bridges", "power_lines", "water_supply"])
    
    def _load_vulnerability_data(self):
        """
        Load infrastructure-specific vulnerability curves and data.
        """
        super()._load_vulnerability_data()
        
        # Add additional infrastructure-specific curves
        # In a real implementation, these would be loaded from infrastructure-specific data sources
        pass
    
    def calculate_damage(self, hazard_type: str, hazard_intensity: float, 
                         asset_properties: Dict[str, Any]) -> float:
        """
        Calculate the damage ratio for infrastructure based on hazard intensity and asset properties.
        
        Args:
            hazard_type (str): Type of hazard (e.g., 'flood', 'earthquake')
            hazard_intensity (float): Intensity value of the hazard at the asset location
            asset_properties (Dict[str, Any]): Properties of the infrastructure asset
            
        Returns:
            float: Damage ratio (0.0 to 1.0)
        """
        # Apply infrastructure-specific logic before calling parent method
        
        # For infrastructure, we may consider network effects
        # For example, bridges might be more critical than roads
        if "infrastructure_type" in asset_properties:
            if asset_properties["infrastructure_type"] == "bridge" and hazard_type == "flood":
                # Adjust intensity for bridges (e.g., scour effects)
                if "river_velocity" in asset_properties:
                    # Increase effective intensity based on water velocity
                    hazard_intensity *= (1.0 + 0.2 * asset_properties["river_velocity"])
        
        # Call parent method with potentially modified parameters
        return super().calculate_damage(hazard_type, hazard_intensity, asset_properties)


class PopulationVulnerabilityModel(VulnerabilityModel):
    """
    Specialized vulnerability model for population vulnerability.
    """
    
    def __init__(self, params: Dict[str, Any]):
        """
        Initialize the population vulnerability model with the specified parameters.
        
        Args:
            params (Dict[str, Any]): Parameters for the population vulnerability model
        """
        super().__init__(vulnerability_type="population", params=params)
        
        # Population-specific parameters
        self.demographic_factors = params.get("demographic_factors", ["age", "income", "mobility", "housing_quality"])
        self.use_social_vulnerability_index = params.get("social_vulnerability_index", True)
    
    def _load_vulnerability_data(self):
        """
        Load population-specific vulnerability curves and data.
        """
        super()._load_vulnerability_data()
        
        # For population vulnerability, we might use social vulnerability indices
        # In a real implementation, these would be loaded from demographic data sources
        
        # Add population-specific vulnerability data
        self.vulnerability_curves["social"] = {
            "high_vulnerability": {
                "intensity_values": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],  # normalized hazard intensity
                "damage_ratios": [0.0, 0.25, 0.50, 0.75, 0.90, 1.0]  # impact ratio
            },
            "medium_vulnerability": {
                "intensity_values": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
                "damage_ratios": [0.0, 0.15, 0.35, 0.55, 0.75, 0.9]
            },
            "low_vulnerability": {
                "intensity_values": [0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
                "damage_ratios": [0.0, 0.10, 0.25, 0.40, 0.60, 0.8]
            }
        }
    
    def calculate_damage(self, hazard_type: str, hazard_intensity: float, 
                         asset_properties: Dict[str, Any]) -> float:
        """
        Calculate the vulnerability impact for a population based on hazard intensity and demographics.
        
        For population, "damage" represents impact rather than physical damage.
        
        Args:
            hazard_type (str): Type of hazard (e.g., 'flood', 'earthquake')
            hazard_intensity (float): Intensity value of the hazard at the location
            asset_properties (Dict[str, Any]): Properties including demographic factors
            
        Returns:
            float: Impact ratio (0.0 to 1.0)
        """
        # For population vulnerability, use social vulnerability if available
        if self.use_social_vulnerability_index and "social_vulnerability" in asset_properties:
            # Use social vulnerability curves
            svi = asset_properties["social_vulnerability"]
            
            # Map SVI to vulnerability category
            if svi >= 0.7:
                vulnerability_category = "high_vulnerability"
            elif svi >= 0.3:
                vulnerability_category = "medium_vulnerability"
            else:
                vulnerability_category = "low_vulnerability"
            
            # Normalize hazard intensity based on hazard type
            normalized_intensity = self._normalize_hazard_intensity(hazard_type, hazard_intensity)
            
            # Use social vulnerability curves
            if "social" in self.vulnerability_curves:
                social_curves = self.vulnerability_curves["social"]
                if vulnerability_category in social_curves:
                    curve = social_curves[vulnerability_category]
                    
                    # Interpolate based on normalized intensity
                    for i in range(len(curve["intensity_values"]) - 1):
                        if curve["intensity_values"][i] <= normalized_intensity < curve["intensity_values"][i+1]:
                            x0, x1 = curve["intensity_values"][i], curve["intensity_values"][i+1]
                            y0, y1 = curve["damage_ratios"][i], curve["damage_ratios"][i+1]
                            
                            impact = y0 + (y1 - y0) * (normalized_intensity - x0) / (x1 - x0)
                            return impact
                    
                    # Handle extremes
                    if normalized_intensity <= curve["intensity_values"][0]:
                        return curve["damage_ratios"][0]
                    if normalized_intensity >= curve["intensity_values"][-1]:
                        return curve["damage_ratios"][-1]
        
        # Fallback to standard vulnerability calculation
        return super().calculate_damage(hazard_type, hazard_intensity, asset_properties)
    
    def _normalize_hazard_intensity(self, hazard_type: str, intensity: float) -> float:
        """
        Normalize hazard intensity to a 0-1 scale for use with social vulnerability curves.
        
        Args:
            hazard_type (str): Type of hazard
            intensity (float): Raw hazard intensity
            
        Returns:
            float: Normalized intensity (0.0 to 1.0)
        """
        # Simple normalization based on typical ranges for each hazard
        if hazard_type == "flood":
            # Assume flood depths beyond 3m are maximum impact
            return min(1.0, intensity / 3.0)
        
        elif hazard_type == "earthquake":
            # Assume PGA beyond 0.8g is maximum impact
            return min(1.0, intensity / 0.8)
        
        elif hazard_type == "hurricane":
            # Assume wind speeds beyond 150 m/s are maximum impact
            return min(1.0, intensity / 150.0)
        
        elif hazard_type == "wildfire":
            # Assume fire intensity beyond 50 kW/m is maximum impact
            return min(1.0, intensity / 50.0)
        
        # Default normalization (linear 0-1 mapping)
        return min(1.0, max(0.0, intensity / 100.0)) 