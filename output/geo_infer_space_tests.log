============================= test session starts ==============================
platform darwin -- Python 3.13.5, pytest-8.4.1, pluggy-1.6.0
rootdir: /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/tests
configfile: pytest.ini
plugins: anyio-4.9.0
collected 28 items

tests/test_base_module.py ..                                             [  7%]
tests/test_core.py ..                                                    [ 14%]
tests/test_data_integrator.py .                                          [ 17%]
tests/test_enhanced_reporting.py ..                                      [ 25%]
tests/test_osc_geo.py ..FFF..                                            [ 50%]
tests/test_osc_scripts.py FF                                             [ 57%]
tests/test_place_analyzer.py ..                                          [ 64%]
tests/test_spatial_processor.py ...                                      [ 75%]
tests/test_unified_backend.py FF.F.                                      [ 92%]
tests/test_visualization_engine.py ..                                    [100%]

=================================== FAILURES ===================================
_____________________________ test_h3_grid_manager _____________________________

    @pytest.mark.integration
    def test_h3_grid_manager():
        """Test H3GridManager lifecycle."""
        manager = H3GridManager(auto_start=False)
        assert not manager.is_server_running()
        success = manager.start_server()
>       assert success
E       assert False

tests/test_osc_geo.py:31: AssertionError
----------------------------- Captured stdout call -----------------------------
DEBUG: get_repo_path - received base_dir: None
DEBUG: get_repo_path - OSC_REPOS_DIR env var: None
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.osc_geo.core.h3grid:h3grid.py:114 Failed to start H3 grid service: [Errno 2] No such file or directory: './repo/osc-geo-h3grid-srv/venv/bin/python'
_____________________________ test_h3_data_loader ______________________________

tmp_path = PosixPath('/private/var/folders/vc/rgmbpjpj0dbg61vr54xjskc80000gn/T/pytest-of-4d/pytest-4/test_h3_data_loader0')

    @pytest.mark.integration
    def test_h3_data_loader(tmp_path):
        """Test loading data to H3 grid."""
        # Create sample GeoJSON
        sample_geojson = {
            'type': 'FeatureCollection',
            'features': [{
                'type': 'Feature',
                'properties': {},
                'geometry': {'type': 'Point', 'coordinates': [0, 0]}
            }]
        }
        input_file = tmp_path / 'sample.geojson'
        with open(input_file, 'w') as f:
            json.dump(sample_geojson, f)
        output_file = tmp_path / 'output_h3.geojson'
>       loader = H3DataLoader()
                 ^^^^^^^^^^^^^^

tests/test_osc_geo.py:53: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/geo_infer_space/osc_geo/core/loader.py:41: in __init__
    self._check_loader_installation()
src/geo_infer_space/osc_geo/core/loader.py:87: in _check_loader_installation
    install_process = subprocess.run(
/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:554: in run
    with Popen(*popenargs, **kwargs) as process:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:1039: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['./repo/osc-geo-h3loader-cli/venv/bin/pip', '...>
args = ['./repo/osc-geo-h3loader-cli/venv/bin/pip', 'install', '-e', '.']
executable = b'./repo/osc-geo-h3loader-cli/venv/bin/pip', preexec_fn = None
close_fds = True, pass_fds = (), cwd = './repo/osc-geo-h3loader-cli'
env = {'BUNDLED_DEBUGPY_PATH': '/Users/4d/.cursor/extensions/ms-python.debugpy-2025.8.0-darwin-arm64/bundled/libs/debugpy', 'CLAUDE_CODE_SSE_PORT': '62091', 'COLORTERM': 'truecolor', 'COMMAND_MODE': 'unix2003', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = 13, c2pwrite = 14, errread = 15, errwrite = 16
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False, process_group = -1

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session, process_group):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and (not close_fds or _HAVE_POSIX_SPAWN_CLOSEFROM)
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and process_group == -1
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals, close_fds,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        process_group, gid, gids, uid, umask,
                        preexec_fn, _USE_VFORK)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                if err_msg == "noexec:chdir":
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                elif err_msg == "noexec":
                    err_msg = ""
                    err_filename = None
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                if err_filename is not None:
>                   raise child_exception_type(errno_num, err_msg, err_filename)
E                   FileNotFoundError: [Errno 2] No such file or directory: './repo/osc-geo-h3loader-cli/venv/bin/pip'

/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:1972: FileNotFoundError
----------------------------- Captured stdout call -----------------------------
DEBUG: get_repo_path - received base_dir: None
DEBUG: get_repo_path - OSC_REPOS_DIR env var: None
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.osc_geo.core.loader:loader.py:103 Error checking/installing H3 loader CLI: [Errno 2] No such file or directory: './repo/osc-geo-h3loader-cli/venv/bin/pip'
__________________________ test_load_data_to_h3_grid ___________________________

tmp_path = PosixPath('/private/var/folders/vc/rgmbpjpj0dbg61vr54xjskc80000gn/T/pytest-of-4d/pytest-4/test_load_data_to_h3_grid0')

    @pytest.mark.integration
    def test_load_data_to_h3_grid(tmp_path):
        """Test high-level load_data_to_h3_grid function."""
        # Create sample GeoJSON
        sample_geojson = {
            'type': 'FeatureCollection',
            'features': [{
                'type': 'Feature',
                'properties': {},
                'geometry': {'type': 'Point', 'coordinates': [0, 0]}
            }]
        }
        input_file = tmp_path / 'sample.geojson'
        with open(input_file, 'w') as f:
            json.dump(sample_geojson, f)
        output_file = tmp_path / 'output_h3.geojson'
>       success = load_data_to_h3_grid(str(input_file), str(output_file), resolution=8)
                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests/test_osc_geo.py:74: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/geo_infer_space/osc_geo/main.py:127: in load_data_to_h3_grid
    loader = create_h3_data_loader(repo_base_dir)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/geo_infer_space/osc_geo/main.py:102: in create_h3_data_loader
    return H3DataLoader(repo_base_dir=repo_base_dir)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
src/geo_infer_space/osc_geo/core/loader.py:41: in __init__
    self._check_loader_installation()
src/geo_infer_space/osc_geo/core/loader.py:87: in _check_loader_installation
    install_process = subprocess.run(
/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:554: in run
    with Popen(*popenargs, **kwargs) as process:
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^
/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:1039: in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <Popen: returncode: 255 args: ['./repo/osc-geo-h3loader-cli/venv/bin/pip', '...>
args = ['./repo/osc-geo-h3loader-cli/venv/bin/pip', 'install', '-e', '.']
executable = b'./repo/osc-geo-h3loader-cli/venv/bin/pip', preexec_fn = None
close_fds = True, pass_fds = (), cwd = './repo/osc-geo-h3loader-cli'
env = {'BUNDLED_DEBUGPY_PATH': '/Users/4d/.cursor/extensions/ms-python.debugpy-2025.8.0-darwin-arm64/bundled/libs/debugpy', 'CLAUDE_CODE_SSE_PORT': '62091', 'COLORTERM': 'truecolor', 'COMMAND_MODE': 'unix2003', ...}
startupinfo = None, creationflags = 0, shell = False, p2cread = -1
p2cwrite = -1, c2pread = 13, c2pwrite = 14, errread = 15, errwrite = 16
restore_signals = True, gid = None, gids = None, uid = None, umask = -1
start_new_session = False, process_group = -1

    def _execute_child(self, args, executable, preexec_fn, close_fds,
                       pass_fds, cwd, env,
                       startupinfo, creationflags, shell,
                       p2cread, p2cwrite,
                       c2pread, c2pwrite,
                       errread, errwrite,
                       restore_signals,
                       gid, gids, uid, umask,
                       start_new_session, process_group):
        """Execute program (POSIX version)"""
    
        if isinstance(args, (str, bytes)):
            args = [args]
        elif isinstance(args, os.PathLike):
            if shell:
                raise TypeError('path-like args is not allowed when '
                                'shell is true')
            args = [args]
        else:
            args = list(args)
    
        if shell:
            # On Android the default shell is at '/system/bin/sh'.
            unix_shell = ('/system/bin/sh' if
                      hasattr(sys, 'getandroidapilevel') else '/bin/sh')
            args = [unix_shell, "-c"] + args
            if executable:
                args[0] = executable
    
        if executable is None:
            executable = args[0]
    
        sys.audit("subprocess.Popen", executable, args, cwd, env)
    
        if (_USE_POSIX_SPAWN
                and os.path.dirname(executable)
                and preexec_fn is None
                and (not close_fds or _HAVE_POSIX_SPAWN_CLOSEFROM)
                and not pass_fds
                and cwd is None
                and (p2cread == -1 or p2cread > 2)
                and (c2pwrite == -1 or c2pwrite > 2)
                and (errwrite == -1 or errwrite > 2)
                and not start_new_session
                and process_group == -1
                and gid is None
                and gids is None
                and uid is None
                and umask < 0):
            self._posix_spawn(args, executable, env, restore_signals, close_fds,
                              p2cread, p2cwrite,
                              c2pread, c2pwrite,
                              errread, errwrite)
            return
    
        orig_executable = executable
    
        # For transferring possible exec failure from child to parent.
        # Data format: "exception name:hex errno:description"
        # Pickle is not used; it is complex and involves memory allocation.
        errpipe_read, errpipe_write = os.pipe()
        # errpipe_write must not be in the standard io 0, 1, or 2 fd range.
        low_fds_to_close = []
        while errpipe_write < 3:
            low_fds_to_close.append(errpipe_write)
            errpipe_write = os.dup(errpipe_write)
        for low_fd in low_fds_to_close:
            os.close(low_fd)
        try:
            try:
                # We must avoid complex work that could involve
                # malloc or free in the child process to avoid
                # potential deadlocks, thus we do all this here.
                # and pass it to fork_exec()
    
                if env is not None:
                    env_list = []
                    for k, v in env.items():
                        k = os.fsencode(k)
                        if b'=' in k:
                            raise ValueError("illegal environment variable name")
                        env_list.append(k + b'=' + os.fsencode(v))
                else:
                    env_list = None  # Use execv instead of execve.
                executable = os.fsencode(executable)
                if os.path.dirname(executable):
                    executable_list = (executable,)
                else:
                    # This matches the behavior of os._execvpe().
                    executable_list = tuple(
                        os.path.join(os.fsencode(dir), executable)
                        for dir in os.get_exec_path(env))
                fds_to_keep = set(pass_fds)
                fds_to_keep.add(errpipe_write)
                self.pid = _fork_exec(
                        args, executable_list,
                        close_fds, tuple(sorted(map(int, fds_to_keep))),
                        cwd, env_list,
                        p2cread, p2cwrite, c2pread, c2pwrite,
                        errread, errwrite,
                        errpipe_read, errpipe_write,
                        restore_signals, start_new_session,
                        process_group, gid, gids, uid, umask,
                        preexec_fn, _USE_VFORK)
                self._child_created = True
            finally:
                # be sure the FD is closed no matter what
                os.close(errpipe_write)
    
            self._close_pipe_fds(p2cread, p2cwrite,
                                 c2pread, c2pwrite,
                                 errread, errwrite)
    
            # Wait for exec to fail or succeed; possibly raising an
            # exception (limited in size)
            errpipe_data = bytearray()
            while True:
                part = os.read(errpipe_read, 50000)
                errpipe_data += part
                if not part or len(errpipe_data) > 50000:
                    break
        finally:
            # be sure the FD is closed no matter what
            os.close(errpipe_read)
    
        if errpipe_data:
            try:
                pid, sts = os.waitpid(self.pid, 0)
                if pid == self.pid:
                    self._handle_exitstatus(sts)
                else:
                    self.returncode = sys.maxsize
            except ChildProcessError:
                pass
    
            try:
                exception_name, hex_errno, err_msg = (
                        errpipe_data.split(b':', 2))
                # The encoding here should match the encoding
                # written in by the subprocess implementations
                # like _posixsubprocess
                err_msg = err_msg.decode()
            except ValueError:
                exception_name = b'SubprocessError'
                hex_errno = b'0'
                err_msg = 'Bad exception data from child: {!r}'.format(
                              bytes(errpipe_data))
            child_exception_type = getattr(
                    builtins, exception_name.decode('ascii'),
                    SubprocessError)
            if issubclass(child_exception_type, OSError) and hex_errno:
                errno_num = int(hex_errno, 16)
                if err_msg == "noexec:chdir":
                    err_msg = ""
                    # The error must be from chdir(cwd).
                    err_filename = cwd
                elif err_msg == "noexec":
                    err_msg = ""
                    err_filename = None
                else:
                    err_filename = orig_executable
                if errno_num != 0:
                    err_msg = os.strerror(errno_num)
                if err_filename is not None:
>                   raise child_exception_type(errno_num, err_msg, err_filename)
E                   FileNotFoundError: [Errno 2] No such file or directory: './repo/osc-geo-h3loader-cli/venv/bin/pip'

/opt/homebrew/Cellar/python@3.13/3.13.5/Frameworks/Python.framework/Versions/3.13/lib/python3.13/subprocess.py:1972: FileNotFoundError
----------------------------- Captured stdout call -----------------------------
DEBUG: get_repo_path - received base_dir: None
DEBUG: get_repo_path - OSC_REPOS_DIR env var: None
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.osc_geo.core.loader:loader.py:103 Error checking/installing H3 loader CLI: [Errno 2] No such file or directory: './repo/osc-geo-h3loader-cli/venv/bin/pip'
______________________ TestOSCScripts.test_osc_setup_all _______________________

self = <test_osc_scripts.TestOSCScripts testMethod=test_osc_setup_all>

    def test_osc_setup_all(self):
        """Test osc_setup_all.py clones repos without running tests."""
        script = self.script_dir / 'osc_setup_all.py'
        result = subprocess.run([str(script), '--output-dir', str(self.temp_repo_dir), '--skip-tests'], capture_output=True, text=True)
        # self.assertEqual(result.returncode, 0) # Temporarily removed to allow test to pass if directories are created
>       self.assertTrue(any('osc-geo' in str(child) for child in self.temp_repo_dir.iterdir()))
E       AssertionError: False is not true

tests/test_osc_scripts.py:21: AssertionError
________________________ TestOSCScripts.test_osc_status ________________________

self = <test_osc_scripts.TestOSCScripts testMethod=test_osc_status>

    def test_osc_status(self):
        """Test osc_status.py runs and outputs status information."""
        script = self.script_dir / 'osc_status.py'
        result = subprocess.run([str(script)], capture_output=True, text=True)
>       self.assertEqual(result.returncode, 0)
E       AssertionError: 1 != 0

tests/test_osc_scripts.py:27: AssertionError
________________ TestUnifiedH3Backend.test_define_target_region ________________

self = <test_unified_backend.TestUnifiedH3Backend testMethod=test_define_target_region>

    def test_define_target_region(self):
        """Test target region definition with small real geometry."""
        # Small real polygon as GeoJSON dict
        test_geom = {
            'TestArea': {
                'all': {
                    'type': 'Polygon',
                    'coordinates': [[[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]]
                }
            }
        }
        # Override _get_geometries to return real dict
        self.backend._get_geometries = lambda x: test_geom
        hex_by_area, all_hex = self.backend._define_target_region({'TestArea': ['all']})
>       self.assertGreater(len(all_hex), 0)
E       AssertionError: 0 not greater than 0

tests/test_unified_backend.py:64: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:114 No geometries could be loaded or defined. Cannot define a target region.
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:133 H3 polyfill failed for all, TestRegion: Unrecognized type: <class 'dict'>
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:139 Failed to generate any H3 hexagons for region 'TestRegion' with filters {'TestRegion': ['all']}
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:133 H3 polyfill failed for all, TestArea: Unrecognized type: <class 'dict'>
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:139 Failed to generate any H3 hexagons for region 'TestRegion' with filters {'TestArea': ['all']}
________________ TestUnifiedH3Backend.test_export_unified_data _________________

self = <test_unified_backend.TestUnifiedH3Backend testMethod=test_export_unified_data>

    def test_export_unified_data(self):
        """Test data export to JSON."""
        self.backend.run_comprehensive_analysis()
        temp_file = Path(tempfile.NamedTemporaryFile(suffix='.json', delete=False).name)
>       self.backend.export_unified_data(str(temp_file), 'json')

tests/test_unified_backend.py:87: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <geo_infer_space.core.unified_backend.UnifiedH3Backend object at 0x123836e00>
output_path = '/var/folders/vc/rgmbpjpj0dbg61vr54xjskc80000gn/T/tmp38tktunk.json'
export_format = 'json'

    def export_unified_data(self, output_path: str, export_format: str = 'geojson') -> None:
        """
        Export unified data and scores to a specified format.
    
        Args:
            output_path: Output file path.
            export_format: 'geojson', 'csv', or 'json'.
        """
        if not self.unified_data:
>           raise ValueError("No unified data to export. Please run the analysis first.")
E           ValueError: No unified data to export. Please run the analysis first.

src/geo_infer_space/core/unified_backend.py:300: ValueError
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:114 No geometries could be loaded or defined. Cannot define a target region.
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:133 H3 polyfill failed for all, TestRegion: Unrecognized type: <class 'dict'>
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:139 Failed to generate any H3 hexagons for region 'TestRegion' with filters {'TestRegion': ['all']}
_____________ TestUnifiedH3Backend.test_get_comprehensive_summary ______________

self = <test_unified_backend.TestUnifiedH3Backend testMethod=test_get_comprehensive_summary>

    def test_get_comprehensive_summary(self):
        """Test summary generation."""
        self.backend.run_comprehensive_analysis()
        summary = self.backend.get_comprehensive_summary()
>       self.assertNotIn('error', summary)
E       AssertionError: 'error' unexpectedly found in {'error': 'Analysis has not been run.'}

tests/test_unified_backend.py:79: AssertionError
------------------------------ Captured log call -------------------------------
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:114 No geometries could be loaded or defined. Cannot define a target region.
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:133 H3 polyfill failed for all, TestRegion: Unrecognized type: <class 'dict'>
ERROR    geo_infer_space.core.unified_backend:unified_backend.py:139 Failed to generate any H3 hexagons for region 'TestRegion' with filters {'TestRegion': ['all']}
=============================== warnings summary ===============================
test_data_integrator.py::TestDataIntegrator::test_integrate_data
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/geo_infer_space_env/lib/python3.13/site-packages/pyogrio/__init__.py:7: DeprecationWarning: The 'shapely.geos' module is deprecated, and will be removed in a future version. All attributes of 'shapely.geos' are available directly from the top-level 'shapely' namespace (since shapely 2.0.0).
    import shapely.geos  # noqa: F401

test_data_integrator.py::TestDataIntegrator::test_integrate_data
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/geo_infer_space_env/lib/python3.13/site-packages/geopandas/array.py:1755: UserWarning: CRS not set for some of the concatenation inputs. Setting output's CRS as WGS 84 (the single non-null crs provided).
    return GeometryArray(data, crs=_get_common_crs(to_concat))

test_enhanced_reporting.py::test_enhanced_reporting
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/geo_infer_space_env/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_enhanced_reporting.py::test_enhanced_reporting returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_enhanced_reporting.py::test_basic_status
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/geo_infer_space_env/lib/python3.13/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but test_enhanced_reporting.py::test_basic_status returned <class 'bool'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

test_place_analyzer.py::TestPlaceAnalyzer::test_perform_spatial_analysis
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/src/geo_infer_space/core/spatial_processor.py:30: UserWarning: Geometry is in a geographic CRS. Results from 'buffer' are likely incorrect. Use 'GeoSeries.to_crs()' to re-project geometries to a projected CRS before this operation.
  
    buffered['geometry'] = gdf.geometry.buffer(buffer_distance)

test_unified_backend.py::TestUnifiedH3Backend::test_define_target_region
test_unified_backend.py::TestUnifiedH3Backend::test_export_unified_data
test_unified_backend.py::TestUnifiedH3Backend::test_generate_interactive_dashboard
test_unified_backend.py::TestUnifiedH3Backend::test_get_comprehensive_summary
test_unified_backend.py::TestUnifiedH3Backend::test_run_comprehensive_analysis
  /Users/4d/Documents/GitHub/GEO-INFER/GEO-INFER-SPACE/src/geo_infer_space/core/unified_backend.py:166: DeprecationWarning: The 'unary_union' attribute is deprecated, use the 'union_all()' method instead.
    geom = area_gdf.unary_union

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_osc_geo.py::test_h3_grid_manager - assert False
FAILED tests/test_osc_geo.py::test_h3_data_loader - FileNotFoundError: [Errno...
FAILED tests/test_osc_geo.py::test_load_data_to_h3_grid - FileNotFoundError: ...
FAILED tests/test_osc_scripts.py::TestOSCScripts::test_osc_setup_all - Assert...
FAILED tests/test_osc_scripts.py::TestOSCScripts::test_osc_status - Assertion...
FAILED tests/test_unified_backend.py::TestUnifiedH3Backend::test_define_target_region
FAILED tests/test_unified_backend.py::TestUnifiedH3Backend::test_export_unified_data
FAILED tests/test_unified_backend.py::TestUnifiedH3Backend::test_get_comprehensive_summary
============ 8 failed, 20 passed, 10 warnings in 186.07s (0:03:06) =============
